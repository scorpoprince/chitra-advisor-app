"""
Single stock idea analysis.

This module glues together symbol normalisation, technical calculation and
OpenAI prompt construction to generate a narrative stock idea.  It contains
no Streamlit code and can be imported from the main app or tested in
isolation.  Debug logging is provided via the utils.logger.
"""

import time
from typing import Dict
from openai import OpenAI

from .symbols import normalize_symbol
from .technicals import get_basic_technicals
from .utils import logger


# Instantiate a single OpenAI client for reuse.  This object will be
# monkeypatched in tests to avoid external API calls.
client = OpenAI()


def _safe_chat(
    system_prompt: str,
    user_prompt: str,
    model: str = "gpt-4.1-mini",
    max_tokens: int = 900,
    temperature: float = 0.4,
) -> str:
    """
    Wrapper around OpenAI's chat completions API with basic retry logic.

    The older gpt-3.5 and gpt-4 models accept ``max_tokens``, whereas
    the newer models (gpt-5.x, o-series) expect ``max_completion_tokens``.
    This function will detect the model name and set the appropriate
    parameter to avoid errors.
    """
    last_err = None
    # Determine which parameter to use based on model name prefix
    if model.startswith("gpt-5") or model.startswith("o"):
        token_param = {"max_completion_tokens": max_tokens}
    else:
        token_param = {"max_tokens": max_tokens}
    for attempt in range(3):
        try:
            resp = client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt},
                ],
                temperature=temperature,
                **token_param,
            )
            return resp.choices[0].message.content.strip()
        except Exception as exc:
            last_err = exc
            msg = str(exc).lower()
            # crude detection of transient errors
            if "rate" in msg or "timeout" in msg or "overloaded" in msg:
                time.sleep(2 ** attempt)
                continue
            break
    raise RuntimeError(f"OpenAI call failed: {last_err}")


def _resolve_name_with_ai(text: str, model: str) -> str:
    """
    If the user enters a descriptive company name, ask the model to map it
    to a likely NSE ticker.  If resolution fails, return ``UNKNOWN``.
    This helper caches results internally via a module-level dict.
    """
    key = text.strip().lower()
    # Use a simple cache to avoid repeated API calls for the same name.
    if not hasattr(_resolve_name_with_ai, "_cache"):
        _resolve_name_with_ai._cache = {}
    cache = _resolve_name_with_ai._cache
    if key in cache:
        return cache[key]
    system = (
        "You are an assistant that maps Indian stock names/descriptions to NSE symbols. "
        "Always return ONLY the NSE symbol like 'MARUTI.NS'. "
        "If you are not sure, return the word UNKNOWN."
    )
    user = (
        f"User typed: '{text}'.\n"
        "What is the most likely NSE symbol? Reply with only the symbol or UNKNOWN."
    )
    try:
        ans = _safe_chat(system, user, model=model, max_tokens=20)
    except Exception:
        cache[key] = "UNKNOWN"
        return "UNKNOWN"
    sym = ans.strip().upper()
    if "UNKNOWN" in sym:
        sym = "UNKNOWN"
    cache[key] = sym
    return sym


def analyze_single_stock(
    user_typed: str,
    capital: float,
    risk_profile: str,
    holding_period_days: int,
    language: str = "en",
    model: str = "gpt-4.1-mini",
) -> Dict:
    """
    Return a dictionary containing a single stock idea for the UI.

    The result includes the resolved ticker, the technical metrics and a
    markdown explanation generated by the OpenAI API.  It raises
    descriptive errors when the input cannot be resolved to a known ticker.
    """
    if not user_typed or not user_typed.strip():
        raise ValueError("Please enter a company name or NSE symbol.")

    text = user_typed.strip()
    symbol_guess = normalize_symbol(text)

    # Try the naive ticker first.
    try:
        metrics = get_basic_technicals(symbol_guess)
        resolved_symbol = symbol_guess
    except Exception:
        # On failure, attempt AI name resolution if the input contains spaces.
        if " " in text:
            ai_symbol = _resolve_name_with_ai(text, model=model)
            if ai_symbol != "UNKNOWN":
                metrics = get_basic_technicals(ai_symbol)
                resolved_symbol = ai_symbol
            else:
                raise RuntimeError(
                    "Could not find price data for what you typed. "
                    "Please try again using the NSE symbol, e.g. 'TCS' or 'TCS.NS'."
                )
        else:
            raise

    # Define human‑friendly descriptions of the risk levels.
    risk_text = {
        "Low": "very conservative, capital preservation focused",
        "Medium": "balanced risk and return",
        "High": "aggressive, willing to take drawdowns for higher return",
        "All or Nothing": "extremely aggressive, okay with large loss if thesis fails",
    }.get(risk_profile, "balanced risk and return")

    lang_label = "English" if language == "en" else "Hindi"

    system_prompt = (
        "You are ChitraAdvisor, a friendly Indian stock helper for a retail investor. "
        "You DO NOT give guaranteed advice – only model-based, educational views.\n\n"
        "You must always respect risk profile and give clear levels (entry, stop, targets). "
        "Assume Indian equity market, delivery trades (no intraday leverage). "
    )

    user_prompt = f"""\
User wants a single stock idea.

Symbol: {resolved_symbol}
Total capital user is considering for THIS idea (not full portfolio): ₹{capital:,.0f}
Risk profile: {risk_profile} ({risk_text})
Intended holding period: ~{holding_period_days} days
Language for explanation: {lang_label}

Recent technical snapshot (approx):
- Last close: ₹{metrics['last_close']}
- 50-day MA: ₹{metrics['ma50']}
- 200-day MA: ₹{metrics['ma200']}
- 1-year return: {metrics['one_year_return_pct']}%
- Annualised volatility: {metrics['vol_annual']}
- RSI(14): {metrics['rsi14']}
- Support: ₹{metrics['support']}
- Resistance: ₹{metrics['resistance']}
- Pivot / reference level: ₹{metrics['pivot']}

TASK:
1. Decide a clear ACTION among:
   BUY, AVOID, HOLD, PARTIAL EXIT, or SELL.
2. Suggest:
   - Ideal entry zone (one price or a narrow range)
   - Stop loss level
   - 1–2 target levels
   - How much of the user's capital is reasonable to allocate (as % of capital)
   - Short comment on expected volatility and risk.
3. Explain the reasoning in simple {lang_label}, in 5–8 bullet points max.
4. Tone: calm, realistic, no hype. Reiterate that this is NOT guaranteed advice.

FORMAT (very important) – answer EXACTLY in this markdown layout:

Action: <one of BUY / AVOID / HOLD / PARTIAL EXIT / SELL>

Entry zone: ₹<x> – ₹<y>  (or just one price)
Stop loss: ₹<z>
Targets: ₹<t1> (and ₹<t2> if you want)
Suggested allocation: <p>% of the capital for this idea

Holding view:
<one short sentence about time horizon & conditions to re-evaluate>

Reasoning:
- point 1
- point 2
- ...
- point N

Risk reminder:
<one short line reminding this is educational only>
"""  # noqa: E501

    analysis_markdown = _safe_chat(system_prompt, user_prompt, model=model, max_tokens=700)

    return {
        "resolved_symbol": resolved_symbol,
        "display_symbol": resolved_symbol,
        "metrics": metrics,
        "analysis_markdown": analysis_markdown,
    }

__all__ = ["analyze_single_stock"]